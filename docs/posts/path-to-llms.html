<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Path to LLMs</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-07ba0ad10f5680c660e360ac31d2f3b6.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-7fccaa5a4effadb8a2e8cfc8e0465904.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#math-background" id="toc-math-background" class="nav-link active" data-scroll-target="#math-background">Math background</a>
  <ul class="collapse">
  <li><a href="#probability" id="toc-probability" class="nav-link" data-scroll-target="#probability">Probability</a></li>
  <li><a href="#information-theory" id="toc-information-theory" class="nav-link" data-scroll-target="#information-theory">Information Theory</a></li>
  <li><a href="#linear-algebra" id="toc-linear-algebra" class="nav-link" data-scroll-target="#linear-algebra">Linear Algebra</a></li>
  <li><a href="#calculus" id="toc-calculus" class="nav-link" data-scroll-target="#calculus">Calculus</a></li>
  </ul></li>
  <li><a href="#optimization-in-ml" id="toc-optimization-in-ml" class="nav-link" data-scroll-target="#optimization-in-ml">Optimization in ML</a></li>
  <li><a href="#automatic-differentiation" id="toc-automatic-differentiation" class="nav-link" data-scroll-target="#automatic-differentiation">Automatic Differentiation</a></li>
  <li><a href="#what-are-neural-networks" id="toc-what-are-neural-networks" class="nav-link" data-scroll-target="#what-are-neural-networks">What are neural networks?</a></li>
  <li><a href="#what-is-language-modeling" id="toc-what-is-language-modeling" class="nav-link" data-scroll-target="#what-is-language-modeling">What is language modeling?</a></li>
  <li><a href="#how-is-language-modeling-done-with-neural-networks" id="toc-how-is-language-modeling-done-with-neural-networks" class="nav-link" data-scroll-target="#how-is-language-modeling-done-with-neural-networks">How is language modeling done with neural networks?</a></li>
  <li><a href="#large-language-models" id="toc-large-language-models" class="nav-link" data-scroll-target="#large-language-models">Large Language Models</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Path to LLMs</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><em>Last updated</em>: Oct 18, 2024.</p>
<hr>
<p>This post is my attempt to draw the shortest path from knowing a little bit of ML to understanding state of the art language models. It includes both milestone papers and the best resources I’ve found to understand a concept. I also like knowing the history of things so there will be a bunch of papers that might really only be of historical interest.</p>
<p>This is a <em>personal</em> path, with the goal of being a reasonably good practitioner of ML, not a researcher. Finally, “path” is a misnomer. It’s more like a garden to get lost in.</p>
<section id="math-background" class="level2">
<h2 class="anchored" data-anchor-id="math-background">Math background</h2>
<p>There is no end to the amount of math one <em>could</em> learn before studying ML, and usually the more I learn the more it seems to help. However, I’ve also found that it’s ok to “lazy-load” the required math once you’ve acquired a decent intuition in each of the major areas. This section therefore is just going to be a list of the areas of math that can be helpful and the best resources I’ve found for learning them.</p>
<p>Ever since I discovered computers my identity has been “programmer”. The book by <span class="citation" data-cites="jeremy_kun_programmers_2021">(<a href="#ref-jeremy_kun_programmers_2021" role="doc-biblioref"><strong>jeremy_kun_programmers_2021?</strong></a>)</span> changed my <em>relationship</em> to math and gave me the confidence to read the ML textbooks and papers. It helped me reconnect with my teenage self that found math playful and was excited by it rather than scared by notation. <strong>This is a life-changing book.</strong></p>
<section id="probability" class="level3">
<h3 class="anchored" data-anchor-id="probability">Probability</h3>
<p>Probability is the foundation for all of ML, statistics, and science. It’s also <em>way more</em> complicated than our brief encounter with it in high school or college makes us believe. I’m always on the look out for books and articles that help in developing a good intuition for probability.</p>
<p>The textbook by <span class="citation" data-cites="hamming_art_1991">(<a href="#ref-hamming_art_1991" role="doc-biblioref"><strong>hamming_art_1991?</strong></a>)</span> is one of the best introductions. It is rigorous enough for us engineers but more importantly has long passages that explain the intuition behind ideas.</p>
</section>
<section id="information-theory" class="level3">
<h3 class="anchored" data-anchor-id="information-theory">Information Theory</h3>
<p>Information seems like the most natural concept to try to understand ML and stats. Many of the questions of interest can be posed as information theory questions: “what has a model learnt?”, or “what did this experiment tell us?”, “how much can a model of a certain size learn?”</p>
<p><span class="citation" data-cites="cover_elements_2005">(<a href="#ref-cover_elements_2005" role="doc-biblioref"><strong>cover_elements_2005?</strong></a>)</span> and <span class="citation" data-cites="mackay_information_2003">(<a href="#ref-mackay_information_2003" role="doc-biblioref"><strong>mackay_information_2003?</strong></a>)</span> are two useful textbooks.</p>
</section>
<section id="linear-algebra" class="level3">
<h3 class="anchored" data-anchor-id="linear-algebra">Linear Algebra</h3>
<p>Linear Algebra has the worst branding in all of math. It’s more exciting to think of the subject as “thinking in high-dimensional spaces”. Everything in ML deals with vectors with impossibly high dimensions (for example, each token in GPT3 is represented as a vector in a ~50,000 dimension space).</p>
<p>The video series “Essence of Linear Algebra” by <span class="citation" data-cites="3blue1brown_essence_2016">(<a href="#ref-3blue1brown_essence_2016" role="doc-biblioref"><strong>3blue1brown_essence_2016?</strong></a>)</span> was the first time linear algebra made any intuitive sense to me.</p>
</section>
<section id="calculus" class="level3">
<h3 class="anchored" data-anchor-id="calculus">Calculus</h3>
<p>ML papers are full of complicated equations with symbols from multivariate and matrix calculus. This might give the impression that one needs a full undergrad course in these topics before making any progress, but I don’t buy it. I think one can get by for a long time with just the intuition of the concept of a derivative (gradient) for complicated functions and the chain rule for computing them.</p>
</section>
</section>
<section id="optimization-in-ml" class="level2">
<h2 class="anchored" data-anchor-id="optimization-in-ml">Optimization in ML</h2>
<p>The goal of all ML training is to find an acceptably low value of the loss function. This is the part of ML that I find it the easiest to treat as a black box.</p>
<p><span class="citation" data-cites="bottou_optimization_2016">(<a href="#ref-bottou_optimization_2016" role="doc-biblioref"><strong>bottou_optimization_2016?</strong></a>)</span> is a great overview of the various optimization methods used in ML.</p>
</section>
<section id="automatic-differentiation" class="level2">
<h2 class="anchored" data-anchor-id="automatic-differentiation">Automatic Differentiation</h2>
<p>AD is the key to training large neural networks. AD libraries automatically figure out the gradient of the loss function as long as the computation of the loss function is expressed in a form that the library expects. For example, in PyTorch the computation is expressed as tensor operations.</p>
<p><span class="citation" data-cites="baydin_automatic_2015">(<a href="#ref-baydin_automatic_2015" role="doc-biblioref"><strong>baydin_automatic_2015?</strong></a>)</span> is a great survey of the various AD methods. For ML training we care about “reverse mode”. <span class="citation" data-cites="paszke_pytorch_2019">(<a href="#ref-paszke_pytorch_2019" role="doc-biblioref"><strong>paszke_pytorch_2019?</strong></a>)</span> describes PyTorch, the most widely used library for deep learning in production.</p>
</section>
<section id="what-are-neural-networks" class="level2">
<h2 class="anchored" data-anchor-id="what-are-neural-networks">What are neural networks?</h2>
<p>The first neural network was the perceptron <span class="citation" data-cites="nilsson_quest_2010">(see <a href="#ref-nilsson_quest_2010" role="doc-biblioref"><strong>nilsson_quest_2010?</strong></a>)</span>, a single-layer network built to identify objects in 20x20 pixel images. I find it fascinating to note that most of the early work on neural networks was done by people trying to understand human cognition by building a model of computation different from the familiar digital (von Neumann) computer. From that perspective, current LLMs running on GPUs are just one physical realization of the model of computation.</p>
<p>The key algorithm for training neural networks is backpropagation. This algorithm has apparently been invented independently many times. <span class="citation" data-cites="rumelhart_learning_1986">(<a href="#ref-rumelhart_learning_1986" role="doc-biblioref"><strong>rumelhart_learning_1986?</strong></a>)</span> is one of the widely cited descriptions of it.</p>
<p><span class="citation" data-cites="lecun_backpropagation_1989">(<a href="#ref-lecun_backpropagation_1989" role="doc-biblioref"><strong>lecun_backpropagation_1989?</strong></a>)</span> is one of the first examples of using neural networks and back propagation to solve the recognizably modern problem of handwriting recognition. An interesting companion piece is the blog post <span class="citation" data-cites="karpathy_deep_2022">(<a href="#ref-karpathy_deep_2022" role="doc-biblioref"><strong>karpathy_deep_2022?</strong></a>)</span> that re-implements the network described in the original paper and illustrates the massive difference in training time made possible by modern hardware.</p>
<p>Another milestone in the deep learning revolution is AlexNet <span class="citation" data-cites="krizhevsky_imagenet_2012">(<a href="#ref-krizhevsky_imagenet_2012" role="doc-biblioref"><strong>krizhevsky_imagenet_2012?</strong></a>)</span> where a deep learning model beat all other previous computer vision models on image recognition by a significant margin. This paper also illustrates the coming together of three factors that make deep learning practical and are true to this day: (1) massive datasets (2) GPUs for efficient matrix computations (3) libraries to do automatic differentiation easily.</p>
</section>
<section id="what-is-language-modeling" class="level2">
<h2 class="anchored" data-anchor-id="what-is-language-modeling">What is language modeling?</h2>
<p>The task of language modeling is to learn a probability distribution about a corpus. The distribution is the conditional probability of the next token given a sequence of previous tokens. A short introduction to language modeling is in <span class="citation" data-cites="hang_li_language_2022">(<a href="#ref-hang_li_language_2022" role="doc-biblioref"><strong>hang_li_language_2022?</strong></a>)</span>.</p>
<p>The roots of this go back to Markov analyzing Pushkin’s poetry to settle a debate about free will(!), described in the article by <span class="citation" data-cites="hayes_first_2013">(<a href="#ref-hayes_first_2013" role="doc-biblioref"><strong>hayes_first_2013?</strong></a>)</span>.</p>
<p>The classic <span class="citation" data-cites="shannon_mathematical_1948">(<a href="#ref-shannon_mathematical_1948" role="doc-biblioref"><strong>shannon_mathematical_1948?</strong></a>)</span> paper that invented information theory also considers language modeling, as does his subsequent paper <span class="citation" data-cites="shannon_prediction_1951">(<a href="#ref-shannon_prediction_1951" role="doc-biblioref"><strong>shannon_prediction_1951?</strong></a>)</span>. In the second paper he describes an experiment to figure out the entropy of English language by giving humans (his wife and another couple) the task of predicting the next word of a short sentence, essentially treating them like modern LLMs!</p>
<p>The Shannon living-room experiments story is related in this entertaining profile: <span class="citation" data-cites="horgan_claude_1992">(<a href="#ref-horgan_claude_1992" role="doc-biblioref"><strong>horgan_claude_1992?</strong></a>)</span>.</p>
</section>
<section id="how-is-language-modeling-done-with-neural-networks" class="level2">
<h2 class="anchored" data-anchor-id="how-is-language-modeling-done-with-neural-networks">How is language modeling done with neural networks?</h2>
<p><span class="citation" data-cites="bengio_neural_2003">(<a href="#ref-bengio_neural_2003" role="doc-biblioref"><strong>bengio_neural_2003?</strong></a>)</span> introduced the ideas of using a neural network to model language as well as the idea of a “distributed representation”, also known as word embeddings. The goal of embedding is to turn words and phrases into vectors in a high-dimensional space.</p>
<p>A big step forward in embeddings was Google’s word2vec paper <span class="citation" data-cites="mikolov_distributed_2013">(<a href="#ref-mikolov_distributed_2013" role="doc-biblioref"><strong>mikolov_distributed_2013?</strong></a>)</span>, which contained the famous example <code>vec("King") - vec("Man") + vec("Woman") ~= vec("Queen")</code>. Embeddings just on their own are an incredibly useful tool in building products because they capture a general notion of semantic “distance” between words, sentences, or entire documents.</p>
<p>Recurrent Neural Nets (RNNs) were one solution to the problem of capturing the <em>sequential</em> nature of language. The historical roots of this approach are in the cognitive science paper <span class="citation" data-cites="elman_finding_1990">(<a href="#ref-elman_finding_1990" role="doc-biblioref"><strong>elman_finding_1990?</strong></a>)</span>. The blog post <span class="citation" data-cites="andrej_karpathy_unreasonable_2015">(<a href="#ref-andrej_karpathy_unreasonable_2015" role="doc-biblioref"><strong>andrej_karpathy_unreasonable_2015?</strong></a>)</span> illustrates the “unreasonable effectiveness” of RNNs.</p>
<p>The playlist “Neural Networks: Zero to Hero” <span class="citation" data-cites="karpathy_neural_2022">(<a href="#ref-karpathy_neural_2022" role="doc-biblioref"><strong>karpathy_neural_2022?</strong></a>)</span> is a step-by-step walkthrough to building something like GPT-2 starting from nothing but knowledge of Python. This entire post is in a sense is all the supplementary reading I’m doing to finish understanding all the videos in this playlist.</p>
</section>
<section id="large-language-models" class="level2">
<h2 class="anchored" data-anchor-id="large-language-models">Large Language Models</h2>
<p>Everything in this section is just the starting point for deeper rabbit holes.</p>
<p>“Attention is all you need” <span class="citation" data-cites="vaswani_attention_2017">(<a href="#ref-vaswani_attention_2017" role="doc-biblioref"><strong>vaswani_attention_2017?</strong></a>)</span> contains the core DNA of all current LLMs. Everything I described in this post above is my attempt to get to a full understanding of this landmark paper.</p>
<p>“State of GPT” <span class="citation" data-cites="andrej_karpathy_state_2023">(<a href="#ref-andrej_karpathy_state_2023" role="doc-biblioref"><strong>andrej_karpathy_state_2023?</strong></a>)</span> is the best 1-hour introduction to the architecture, training and capabilities of LLMs. This talk is accessible to any working programmer, it doesn’t need any previous knowledge of LLMs or neural networks.</p>
<p><span class="citation" data-cites="3blue1brown_neural_2024">(<a href="#ref-3blue1brown_neural_2024" role="doc-biblioref"><strong>3blue1brown_neural_2024?</strong></a>)</span> is a great series of videos on neural networks and deep learning, with recent videos focusing on LLMs.</p>
<p>The papers on open source LLMs have a wealth of detail on the training data and methodology. See LLAMA2 <span class="citation" data-cites="touvron_llama_2023">(<a href="#ref-touvron_llama_2023" role="doc-biblioref"><strong>touvron_llama_2023?</strong></a>)</span>, Mistral 7B <span class="citation" data-cites="jiang_mistral_2023">(<a href="#ref-jiang_mistral_2023" role="doc-biblioref"><strong>jiang_mistral_2023?</strong></a>)</span>.</p>
<p>The effectiveness of neural networks is extremely dependent on the quantity and quality of the training data. This fact is apparently discovered again and again so often that it has a name: “the bitter lesson” <span class="citation" data-cites="rich_sutton_bitter_2019">(<a href="#ref-rich_sutton_bitter_2019" role="doc-biblioref"><strong>rich_sutton_bitter_2019?</strong></a>)</span>. An intriguing related fact about LLMs is the existence of “scaling laws” that describe the optimal model size and number of training tokens for a given compute budget <span class="citation" data-cites="hoffmann_training_2022">(<a href="#ref-hoffmann_training_2022" role="doc-biblioref"><strong>hoffmann_training_2022?</strong></a>)</span>.</p>
<p>The wide applicability of LLMs is a result of their ability to learn to perform tasks with just a handful of examples (“few-shot learning”). This discovery is related in the GPT2 <span class="citation" data-cites="brown_language_2020">(<a href="#ref-brown_language_2020" role="doc-biblioref"><strong>brown_language_2020?</strong></a>)</span> and GPT3 papers <span class="citation" data-cites="kojima_large_2022">(<a href="#ref-kojima_large_2022" role="doc-biblioref"><strong>kojima_large_2022?</strong></a>)</span>.</p>
<p>Training LLMs is an incredibly complicated systems engineering problem. This blog post by the lead of PyTorch <span class="citation" data-cites="chintala_how_2024">(<a href="#ref-chintala_how_2024" role="doc-biblioref"><strong>chintala_how_2024?</strong></a>)</span> and the infrastructure section in the LLama3 paper <span class="citation" data-cites="dubey_llama_2024">(<a href="#ref-dubey_llama_2024" role="doc-biblioref"><strong>dubey_llama_2024?</strong></a>)</span> provide insight into what it takes.</p>
<p>[ <em>to be continued</em> … ]</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>