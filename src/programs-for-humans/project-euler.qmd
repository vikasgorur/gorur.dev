---
title: Project Euler - first 100 problems
toc: true
---
Last updated: _Mar 5, 2025_.

My solutions to the problems from [Project Euler](https://projecteuler.net/archives).

## Problem 1
_Difficulty: 5%_

> Find the sum of all multiples of 3 or 5 below 1000.

```clojure
(->> (range 1000)
     (filter #(or (zero? (mod % 3)) (zero? (mod % 5))))
     (reduce +))
```

<span class="eval-result">233168</span>

## Problem 2
_Difficulty: 5%_

> By considering the terms in the Fibonacci sequence whose values
> do not exceed four million, find the sum of the even-valued terms.

```clojure
(loop [f1 1,
       f2 2,
       even-sum 0]

  (if (>= f2 4000000)
    even-sum
    (if (zero? (mod f2 2))
      (recur f2 (+ f1 f2) (+ even-sum f2))
      (recur f2 (+ f1 f2) even-sum))))
```

<span class="eval-result">4613732</span>

## Problem 3
_Difficulty: 5%_

> Find the largest prime factor of 600851475143.

We'll just brute force all primes below $\sqrt{N}$ and try them as divisors.

```clojure
(let [N 600851475143]
  (->> (primes/sieve-of-eratosthenes (int (Math/sqrt N)))
       reverse
       (filter #(zero? (mod N %)))
       first))
```
<span class="eval-result">6857</span>

## Problem 4
_Difficulty: 5%_

> Find the largest palindrome made from the product of two 3-digit numbers.

We write a function to check if an integer is a palindrome.

```clojure
(defn is-palindrome? [x]
  (let [xstr (Integer/toString x)]
    (= (map char xstr) (reverse xstr))))
```

Run through all $a \times b$ where $a, b \in [100, 999]$.

```clojure
(->> (for [a (range 100 1000)
           b (range 100 1000)
           :when (is-palindrome? (* a b))]
       (* a b))
     sort
     last)
```
<span class="eval-result">906609</span>

## Problem 5
> What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

I was happy to solve this with just pen and paper. Let $N$ be the answer we seek. It has to be divisible by every prime and composite number $\le 20$. But since the composite numbers upto $20$ are themselves just products of primes smaller than themselves, we can write

$$
N = 2^a \cdot 3^b \cdot 5^c \cdot 7^d \cdot 11^e \cdot 13^f \cdot 17^g \cdot 19^h
$$

For each prime above, the exponent has to be the highest exponent of that prime that appears in the factorization of any of the numbers $1..20$. For example, $a = 4$ because $16 = 2^4$ and for $N$ to be divisible by $16$ it must have $2^4$ as a factor. Similarly for $N$ to be divisible by $18$ and $9$ it must have $3^2$ as a factor. By doing this for all the primes we get the answer:

<span class="eval">(* (* 2 2 2 2) (* 3 3) 5 7 11 13 17 19)</span>
<span class="eval-result">232792560</span>

## Problem 6
_Difficulty: 5%_

> Find the difference between the sum of the squares of the first
> one hundred natural numbers and the square of the sum.

```clojure
(- (int (Math/pow (->> (range 1 101)
                       (reduce +))
                  2))
   (->> (range 1 101)
        (map #(int (Math/pow % 2)))
        (reduce +)))
```

<span class="eval-result">25164150</span>

## Problem 7
_Difficulty: 5%_

> What is the 10,001st prime number?

As a consequence of the Prime Number Theorem ([wiki](https://en.wikipedia.org/wiki/Prime_number_theorem)),
the $N$th prime is approximately

$$N \ ln(N)$$

So we'll generate all primes upto a little more than that number and pick out the 10,001st one.

```clojure
(let [N 10001
      approx-nth-prime (* N (Math/log N))]
      (nth (primes/sieve-of-eratosthenes
            (int (* 1.2 approx-nth-prime)))
           (dec N)))
```

<span class="eval-result">104743</span>

## Problem 8
_Difficulty: 5%_

> Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value
> of this product?

We slide a 13-digit window across the 1000-digit number, compute each product and pick the maximum.

```clojure
(def INPUT-8 (filter #(not= % \newline)
                     (slurp "src/code/data/euler-8-input.txt")))

(->> (for [i (range 0 (- (count INPUT-8) 13))]
       (reduce * 1 (map #(Character/digit % 10)
                        (take 13 (drop i INPUT-8)))))
     sort
     last)
```

<span class="eval-result">23514624000</span>

## Problem 9
_Difficulty: 5%_

> Find the one Pythagorean triplet for which $a + b + c = 1000$.

We first write a function to check if a triplet is Pythagorean ($a^2 + b^2 = c^2$).

```clojure
(defn is-pythagorean? [v]
  (let [[a b c] (sort v)]
    (= (* c c)
       (+ (* a a) (* b b)))))
```

```clojure
(->> (for [c (range 1 1000)
           :let [aplusb (- 1000 c)]]
       (for [a (range 1 aplusb)
             :let [b (- aplusb a)]
             :when (and (distinct? a b c)
                        (is-pythagorean? (vector a b c)))]
         (sort [a b c])))
     (mapcat identity)
     distinct
     first
     (reduce * 1))
```

<span class="eval-result">31875000</span>

The triplet is `(200 375 425)`.

## Problem 19
_Difficulty: 5%_

> How many Sundays fell on the first of the month during
> the twentieth century (1 Jan 1901 to 31 Dec 2000)?

First we need the definition of a leap year:

```clojure
(defn is-leap-year? [y]
  (let [four (zero? (mod y 4))
        hundred (zero? (mod y 100))
        four-hundred (zero? (mod y 400))]
    (or (and four (not hundred))
        (and four hundred four-hundred))))
```

<span class="eval">(map is-leap-year? [1900 1996 2000])</span>
<span class="eval-result">(false true true)</span>

Then we need the number of days in any month of any year:

```clojure
(defn days-in-month [m y]
  (case m
    1 31
    2 (if (is-leap-year? y) 29 28)
    3 31
    4 30
    5 31
    6 30
    7 31
    8 31
    9 30
    10 31
    11 30
    12 31))
```

Idiomatic Clojure style is to write immutable code. But I find this problem easier to solve
by imagining adding up the days for each month starting from 1901.

```clojure
(let [day (atom 2)      ;; Jan 1 1901 was a Tuesday
      result (atom 0)]

  (doseq [year (range 1901 2001)
          month (range 1 13)]
    (reset! day (mod (+ @day (days-in-month month year)) 7))
    (when (zero? @day)
      (println year month)
      (swap! result inc)))
  @result)
```

<span class="eval-result">171</span>

## Problem 21
_Difficulty: 5%_

> Let $d(n)$ be the sum of all proper divisors of $n$ (numbers less than $n$ that divide $n$).
> If $d(b) = a$ and $d(a) = b$ while $a \ne b$, then both $a$ and $b$ are called amicable numbers.
> Find the sum of all amicable numbers under 10000.

We sum the proper divisors of a number by brute force.

```clojure
(defn sum-proper-divisors
  "Returns the sum of all divisors of n, excluding n itself"
  [n]
  (->> (range 1 (inc (Math/ceil (/ n 2))))
       (filter #(= (mod n %) 0))
       (reduce + 0)))
```

Define an amicable number.

```clojure
(defn amicable? [a]
  (let [b (sum-proper-divisors a)]
    (and (not= a b)
         (= (sum-proper-divisors b) a))))
```

Check each number under 10000.

```clojure
(->> (range 2 10001)
     (filter amicable?)
     (reduce + 0))
```

<span class="eval-result">31626</span>

## Problem 65
_Difficulty: 15%_


> $e$ can be written as the continued fraction
> $[2; 1, 2, 1, 1, 4, 1, 1, 6, 1, ... , 1, 2k, 1, ...]$
>
> The $n$th "convergent" of a continued fraction is the result of
> summing it upto $n$ terms. Find the sum of the digits in the
> numerator of the 100th convergent of the fraction for $e$.

First we write a generic function to sum the first $n$ terms
of a continued fraction.

```clojure
(defn sum-terms
  [xs]
  (if (empty? xs)
    0
    (/ 1 (+ (first xs) (sum-terms (rest xs))))))
```

We can test that it works by computing $\sqrt{2}$ upto 10 terms.

<span class="eval">(float (+ 1 (sum-terms (repeat 9 2))))</span>
<span class="eval-result">1.4142137</span>

The fraction for $e$ is slightly more complicated because the $k$th
term can be either $2k$ or $1$.

```clojure
(defn e-terms
  "The first n terms of the continued fraction for e"
  [n]
  (take n (map (fn [k]
                 (case (mod k 3)
                   0 1
                   1 (* 2 (inc (quot k 3)))
                   2 1))
               (range n))))
```

Now sum the first 100 terms and compute the sum of the digits
of the numerator.

```clojure
(reduce + (map #(Character/digit % 10)
               (str (numerator (+ 2 (sum-terms (e-terms 99)))))))
```

<span class="eval-result">272</span>


## Helpers

These are helper functions used across problems.

Since many of the problems deal with prime numbers, let's write the Sieve of Eratosthenes to
generate all prime numbers below $n$.

```clojure
(defn sieve-of-eratosthenes
  [n]
  (let [sieve (BitSet. (inc n))]
    ;; Set all bits to true initially
    (.set sieve 0 (inc n))

    ;; 0 and 1 are not prime
    (.clear sieve 0)
    (.clear sieve 1)

    (doseq [x (range 2 (inc (int (Math/sqrt n))))]
      (doseq [i (range 2 (inc (quot n x)))]
        (.clear sieve (* x i))))

    (filter #(.get sieve %) (range 2 n))))
```
